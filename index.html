<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Magenta AI — Offline Data → LLM Packets</title>
  <meta name="color-scheme" content="light" />
  <style>
    :root{--bg:#ffffff;--fg:#0a0a0a;--muted:#6b7280;--line:#ececec;--radius:18px;--shadow:0 8px 28px rgba(0,0,0,.08)}
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--fg);font:16px/1.5 system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,Arial;display:flex;flex-direction:column;min-height:100vh}
    main{flex:1;display:flex;flex-direction:column;align-items:center;justify-content:center;text-align:center;padding:20px}
    h1{font-size:clamp(36px,5vw,60px);font-weight:900;margin:0 0 12px}
    p.sub{font-size:18px;color:var(--muted);max-width:60ch;margin:0 auto 28px}
    .bar{width:min(760px,92%);display:flex;align-items:center;gap:10px;background:#fff;border:1px solid var(--line);border-radius:var(--radius);box-shadow:var(--shadow);padding:14px 18px}
    .bar:focus-within{outline:3px solid rgba(0,0,0,.08)}
    .bar textarea{flex:1;border:none;outline:none;resize:none;min-height:28px;max-height:220px;font:inherit;background:transparent}
    .bar label{font-weight:800;cursor:pointer;white-space:nowrap}
    /* accept all files: no accept filter on input */
    .bar input[type=file]{display:none}
    .row{margin-top:10px;display:flex;gap:12px;justify-content:center;flex-wrap:wrap}
    .pill{border:1px solid var(--line);border-radius:999px;padding:6px 10px;font-size:13px;color:var(--muted)}
    .btn{display:inline-flex;align-items:center;gap:8px;padding:10px 14px;border:1px solid #111;background:#111;color:#fff;border-radius:12px;font-weight:800;cursor:pointer}
    .btn:disabled{opacity:.5;cursor:not-allowed}
    .progress{height:8px;background:#f5f5f7;border:1px solid var(--line);border-radius:999px;overflow:hidden;margin-top:12px;width:min(760px,92%)}
    .progbar{height:100%;width:0;background:#111;transition:width .25s ease}
    .status{margin-top:6px;color:var(--muted);font-size:13px}
    footer{padding:20px;text-align:center;color:var(--muted);font-size:14px}
    details{margin-top:16px;width:min(760px,92%);text-align:left}
    summary{cursor:pointer;font-weight:800}
    pre{white-space:pre-wrap;word-wrap:break-word;background:#fafafa;border:1px solid var(--line);padding:12px;border-radius:12px}
  </style>
</head>
<body>
  <main>
    <h1>Magenta AI</h1>
    <p class="sub">Turn raw datasets into clean, LLM‑ready training packets — <b>fully offline</b>, in your browser. No servers. No API keys.</p>

    <div class="bar">
      <textarea id="input" placeholder="Paste dataset here (CSV / TSV / JSON / JSONL)…"></textarea>
      <label>Upload<input id="file" type="file" /></label>
    </div>

    <div class="row">
      <span class="pill">Mode:</span>
      <button class="btn" data-mode="instruct">Instruct</button>
      <button class="btn" data-mode="pairs">Pairs</button>
      <button class="btn" data-mode="qa">Q&A</button>
      <button class="btn" data-mode="chat">Chat</button>
      <button id="run" class="btn">Generate & Download</button>
    </div>

    <div class="progress" aria-live="polite" aria-label="Progress"><div id="bar" class="progbar"></div></div>
    <div id="status" class="status">Idle</div>

    <details>
      <summary>Advanced (optional)</summary>
      <div class="row" style="justify-content:space-between;gap:8px">
        <div class="pill">Prompt col: <input id="promptCol" style="border:none;outline:none" placeholder="prompt / instruction"/></div>
        <div class="pill">Response col: <input id="respCol" style="border:none;outline:none" placeholder="answer / output"/></div>
        <div class="pill">Chat JSON col: <input id="chatCol" style="border:none;outline:none" placeholder="messages_json"/></div>
        <div class="pill">Delimiter: <input id="delim" style="border:none;outline:none" placeholder="," size="2"/></div>
        <div class="pill">PII action: <select id="pii"><option>redact</option><option>hash</option><option>none</option></select></div>
        <div class="pill">Dedup: <select id="dedupe"><option>near</option><option>exact</option><option>none</option></select></div>
        <div class="pill">Min chars: <input id="minChars" type="number" value="20" style="border:none;outline:none;width:80px"/></div>
        <div class="pill">Max chars: <input id="maxChars" type="number" value="20000" style="border:none;outline:none;width:90px"/></div>
      </div>
    </details>

    <details>
      <summary>What you’ll get</summary>
      <pre>
• <b>packets.jsonl</b> — training rows in your chosen schema
• <b>dataset_manifest.json</b> — counts, config, hash
• <b>DATASET_CARD.md</b> — describes how data was processed
Files are bundled into <b>magenta_packets.zip</b> and downloaded automatically.
      </pre>
    </details>
  </main>

  <footer>© <span id="year"></span> Magenta AI — Simple. Minimal. Focused.</footer>

  <!-- Load JSZip from CDN (ZIP creation fully client-side) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

  <script>
  // -------------------- Utility helpers --------------------
  const yearEl = document.getElementById('year'); yearEl.textContent = new Date().getFullYear();
  const inputEl = document.getElementById('input');
  const fileEl = document.getElementById('file');
  const runBtn = document.getElementById('run');
  const barEl = document.getElementById('bar');
  const statusEl = document.getElementById('status');
  const modeBtns = Array.from(document.querySelectorAll('button.btn[data-mode]'));

  let MODE = 'instruct';
  modeBtns.forEach(b=>{ b.addEventListener('click',()=>{ MODE=b.dataset.mode; modeBtns.forEach(x=>x.disabled=false); b.disabled=true; }); });
  document.querySelector('button.btn[data-mode="instruct"]').disabled = true;

  function setProgress(p, msg){ barEl.style.width = `${p}%`; if(msg) statusEl.textContent = msg; }
  function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

  async function sha256(text){
    const enc = new TextEncoder();
    const buf = await crypto.subtle.digest('SHA-256', enc.encode(text));
    return Array.from(new Uint8Array(buf)).map(b=>b.toString(16).padStart(2,'0')).join('');
  }

  // -------------------- Parsing --------------------
  function detectFormat(text){
    const t = text.trim();
    if(!t) return 'empty';
    if(t.startsWith('{') || t.startsWith('[')) return 'json';
    if(t.includes('\n') && t.split('\n',2)[0].includes(',')) return 'csv';
    if(t.includes('\n') && t.split('\n',2)[0].includes('\t')) return 'tsv';
    const lines = t.split(/\r?\n/).slice(0,3);
    if(lines.every(x=>x.startsWith('{')||x.startsWith('['))) return 'jsonl';
    return 'csv';
  }

  function parseCSV(text, delim){
    const D = delim || (text.split('\n',1)[0].includes('\t') ? '\t' : ',');
    const lines = text.replace(/\r/g,'').split('\n').filter(x=>x.length>0);
    if(!lines.length) return [];
    const out = [];
    const headers = splitLine(lines[0], D);
    for(let i=1;i<lines.length;i++){
      const row = splitLine(lines[i], D);
      const obj = {}; headers.forEach((h,idx)=> obj[h]= row[idx]!==undefined?row[idx]:'' );
      out.push(obj);
    }
    return out;
    function splitLine(line, D){
      const cells=[]; let cur=''; let q=false; for(let i=0;i<line.length;i++){
        const c=line[i];
        if(c==='"'){ if(q && line[i+1]==='"'){cur+='"'; i++;} else {q=!q;} }
        else if(c===D && !q){ cells.push(cur); cur=''; }
        else { cur+=c; }
      } cells.push(cur); return cells;
    }
  }

  function parseJSONorJSONL(text){
    const t=text.trim();
    if(!t) return [];
    if(t.startsWith('[')) return JSON.parse(t);
    const out=[]; for(const line of t.split(/\r?\n/)){ const L=line.trim(); if(!L) continue; out.push(JSON.parse(L)); }
    return out;
  }

  async function readAnyFile(file){
    // Always try to decode as text first; fallback to UTF-8 from ArrayBuffer
    const text = await new Promise((res)=>{ const fr=new FileReader(); fr.onload=()=>res(fr.result||''); fr.onerror=()=>res(''); fr.readAsText(file); });
    if(text && String(text).trim().length>0) return String(text);
    const ab = await new Promise((res)=>{ const fr=new FileReader(); fr.onload=()=>res(fr.result); fr.onerror=()=>res(new ArrayBuffer(0)); fr.readAsArrayBuffer(file); });
    try{ return new TextDecoder('utf-8',{fatal:false}).decode(new Uint8Array(ab)); }catch{ return ''; }
  }

  // -------------------- Cleaning & PII --------------------
  const EMAIL_RE = /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}\b/g;
  const PHONE_RE = /(?:(?<!\d)[+]?\d{1,3}[\s.-]?)?(?:\(\d{3}\)|\d{3})[\s.-]?\d{3}[\s.-]?\d{4}\b/g;
  const IPV4_RE  = /\b(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\b/g;
  const CC_RE    = /\b(?:\d[ -]*?){13,19}\b/g;

  function normalizeText(s){ if(!s) return s; s = s.normalize('NFC'); s = s.replace(/\s+/g,' ').trim(); return s; }
  function luhnOk(num){ let s=0, alt=false; for(let i=num.length-1;i>=0;i--){ let n=num.charCodeAt(i)-48; if(n<0||n>9) continue; if(alt){ n*=2; if(n>9)n-=9;} s+=n; alt=!alt;} return s%10===0; }

  async function protectPII(s, action, salt){
    if(action==='none') return s;
    const replHash = async (m)=>`<HASH:${(await sha256(salt+m.replace(/[\s-]/g,''))).slice(0,16)}>`;
    const replRed = (tag)=>({EMAIL:'<EMAIL>',PHONE:'<PHONE>',IP:'<IP>',CARD:'<CARD>'}[tag]);

    if(action==='hash') s = await replaceAsync(s, EMAIL_RE, m=>replHash(m));
    else s = s.replace(EMAIL_RE, replRed('EMAIL'));
    if(action==='hash') s = await replaceAsync(s, PHONE_RE, m=>replHash(m));
    else s = s.replace(PHONE_RE, replRed('PHONE'));
    if(action==='hash') s = await replaceAsync(s, IPV4_RE, m=>replHash(m));
    else s = s.replace(IPV4_RE, replRed('IP'));
    s = await replaceAsync(s, CC_RE, async (m)=>{ const digits=m.replace(/\D/g,''); if(digits.length>=13&&digits.length<=19 && luhnOk(digits)) return action==='hash'? await replHash(m): replRed('CARD'); return m; });
    return s;
  }

  function replaceAsync(str, regex, asyncFn){
    const promises=[]; str.replace(regex, (match, ...args)=>{ const promise=asyncFn(match,...args); promises.push(promise); return match; });
    return Promise.all(promises).then(results=>{ return str.replace(regex, ()=>results.shift()); });
  }

  // -------------------- Quality / Dedupe --------------------
  const PROFANITY = new Set(['fuck','shit','bitch','asshole','bastard']);
  function looksLikeGibberish(s){ if(!s) return true; if(/(.)\1{8,}/.test(s)) return true; const letters=[...s].filter(c=>/[A-Za-z]/.test(c)).length; const symbols=[...s].filter(c=>!(/[A-Za-z0-9\s]/.test(c))).length; return symbols>letters*0.7; }
  function qualityOK(s, minC, maxC){ if(!s) return false; if(s.length<minC||s.length>maxC) return false; if(looksLikeGibberish(s)) return false; const low=s.toLowerCase(); for(const w of PROFANITY){ if(low.includes(w)) return false; } return true; }

  function simhash(text, bits=64){ if(!text) return 0; const v=new Array(bits).fill(0); const tokens=text.toLowerCase().match(/\w+/g)||[]; for(const token of tokens){ const h=md5int(token); for(let i=0;i<bits;i++){ v[i]+= ((h>>i)&1)?1:-1; } } let fp=0; for(let i=0;i<bits;i++){ if(v[i]>=0) fp|=(1<<i);} return fp; }
  function md5int(s){ let x=0; for(let i=0;i<s.length;i++){ x=((x<<5)-x)+s.charCodeAt(i); x|=0; } return x>>>0; }
  function hamdist(x,y){ return ((x^y)>>>0).toString(2).split('1').length-1 }

  // -------------------- Packet builders --------------------
  function makePairs(prompt, response, meta){ return {input:prompt, output:response, meta}; }
  function makeInstruct(prompt, response, meta){ return {instruction:prompt, response, meta}; }
  function makeQA(q,a,meta){ return {question:q, answer:a, meta}; }
  function makeChat(messages, meta){ return {messages, meta}; }

  // -------------------- Main build --------------------
  async function buildPackets(rows, cfg){
    const out=[]; const seenH=new Set(); const seenS=[]; let kept=0; let total=0;
    for(const rec of rows){ total++;
      let prompt='', response=''; let messages=null;
      if(cfg.mode==='chat'){
        const c = cfg.chatCol && rec[cfg.chatCol];
        if(c){ try{ messages=JSON.parse(c); if(!Array.isArray(messages)) messages=null; }catch(e){ messages=null; } }
        if(!messages){
          const entries=Object.entries(rec).filter(([k,v])=>typeof v==='string' || typeof v==='number');
          entries.sort((a,b)=> String(b[1]).length-String(a[1]).length);
          if(entries.length>=2){ messages=[{role:'user',content:String(entries[1][1])},{role:'assistant',content:String(entries[0][1])}]; }
          else continue;
        }
        for(const m of messages){ m.content = await protectPII(normalizeText(String(m.content||'')), cfg.pii, cfg.salt); }
        const joined = messages.map(m=>m.content).join('\n');
        if(!qualityOK(joined, cfg.minChars, cfg.maxChars)) continue;
        const pkt = makeChat(messages, {uid:crypto.randomUUID(), source:'row'});
        const text = JSON.stringify(pkt);
        const h = await sha256(text);
        if(cfg.dedupe!=='none'){ if(seenH.has(h)) continue; seenH.add(h); }
        if(cfg.dedupe==='near'){ const sh = simhash(text); if(seenS.some(s=>hamdist(s,sh)<=3)) continue; seenS.push(sh); }
        out.push(pkt); kept++;
      } else {
        if(cfg.promptCol && cfg.responseCol){ prompt=String(rec[cfg.promptCol]??''); response=String(rec[cfg.responseCol]??''); }
        else {
          const entries=Object.entries(rec).filter(([k,v])=>typeof v==='string' || typeof v==='number');
          entries.sort((a,b)=> String(b[1]).length-String(a[1]).length);
          if(entries.length>=2){ prompt=String(entries[1][1]); response=String(entries[0][1]); }
          else if(entries.length===1){ prompt=String(entries[0][1]); response=''; }
          else continue;
        }
        prompt = await protectPII(normalizeText(prompt), cfg.pii, cfg.salt);
        response= await protectPII(normalizeText(response),cfg.pii,cfg.salt);
        const both=(prompt+'\n'+response).trim();
        if(!qualityOK(both, cfg.minChars, cfg.maxChars)) continue;
        const meta={uid:crypto.randomUUID(), source:'row'};
        const pkt = cfg.mode==='pairs' ? makePairs(prompt,response,meta)
                  : cfg.mode==='qa' ? makeQA(prompt,response,meta)
                  : makeInstruct(prompt,response,meta);
        const text = JSON.stringify(pkt);
        const h = await sha256(text);
        if(cfg.dedupe!=='none'){ if(seenH.has(h)) continue; seenH.add(h); }
        if(cfg.dedupe==='near'){ const sh = simhash(text); if(seenS.some(s=>hamdist(s,sh)<=3)) continue; seenS.push(sh); }
        out.push(pkt); kept++;
      }
      if(total%200===0) setProgress(Math.min(95, Math.round((total/(rows.length||1))*90)), 'Processing…');
      await sleep(0);
    }
    return {packets:out, kept, total};
  }

  function datasetCard(stats){
    return `# Magenta AI Dataset Card\n\n`+
`**Description**: LLM-ready data packets generated in-browser.\n\n`+
`## Stats\n- Total source records: ${stats.total}\n- Total output packets: ${stats.kept}\n\n`+
`## Schema\n- instruct: {instruction, response, meta}\n- pairs: {input, output, meta}\n- qa: {question, answer, meta}\n- chat: {messages:[{role,content}], meta}\n\n`+
`## Processing\n- Unicode normalization, whitespace cleanup.\n- PII protection: emails/phones/IP/credit-cards (${stats.pii}).\n- Exact + near-duplicate filtering.\n- Basic quality filters.\n\n`+
`## Notes\n- Generated entirely offline in the browser.\n`;
  }

  // -------------------- Wire up UI --------------------
  let pastedText = '';
  inputEl.addEventListener('input', ()=>{ pastedText = inputEl.value; });

  fileEl.addEventListener('change', async (e)=>{
    const f = e.target.files?.[0]; if(!f) return;
    statusEl.textContent = `Reading: ${f.name}`;
    inputEl.value = ''; pastedText = '';
    const text = await readAnyFile(f);
    if(!text || !String(text).trim()){
      statusEl.textContent = 'Could not extract text from this file.';
      setProgress(0);
      fileEl.value='';
      return;
    }
    await runPipeline(String(text));
    fileEl.value='';
  });

  runBtn.addEventListener('click', async ()=>{
    const text = pastedText.trim();
    if(!text){ setProgress(0,'Awaiting input…'); return; }
    await runPipeline(text);
  });

  async function runPipeline(rawText){
    try{
      setProgress(3,'Preparing…');
      const mode = MODE;
      const cfg = {
        mode,
        promptCol: document.getElementById('promptCol').value || null,
        responseCol: document.getElementById('respCol').value || null,
        chatCol: document.getElementById('chatCol').value || null,
        delimiter: document.getElementById('delim').value || null,
        pii: document.getElementById('pii').value || 'redact',
        dedupe: document.getElementById('dedupe').value || 'near',
        minChars: parseInt(document.getElementById('minChars').value || '20',10),
        maxChars: parseInt(document.getElementById('maxChars').value || '20000',10),
        salt: 'magenta_salt'
      };
      setProgress(10,'Parsing…');
      let rows=[];
      const kind = detectFormat(rawText);
      if(kind==='json' || kind==='jsonl') rows = parseJSONorJSONL(rawText);
      else if(kind==='csv' || kind==='tsv') rows = parseCSV(rawText, cfg.delimiter);
      else if(kind==='empty'){ setProgress(0,'No content detected.'); return; }
      else rows = parseCSV(rawText, cfg.delimiter); // best-effort fallback
      if(!rows.length){ setProgress(0,'No rows detected.'); return; }
      setProgress(25,'Building packets…');
      const {packets, kept, total} = await buildPackets(rows, cfg);
      setProgress(92,'Packaging…');
      const jsonl = packets.map(p=>JSON.stringify(p)).join('\n');
      const manifest = JSON.stringify({ total_records_in: total, total_packets_out: kept, mode }, null, 2);
      const card = datasetCard({total, kept, pii: cfg.pii});

      const zip = new JSZip();
      zip.file('packets.jsonl', new Blob([jsonl], {type:'application/json'}));
      zip.file('dataset_manifest.json', new Blob([manifest], {type:'application/json'}));
      zip.file('DATASET_CARD.md', new Blob([card], {type:'text/markdown'}));
      const blob = await zip.generateAsync({type:'blob'});

      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = `magenta_packets_${Date.now()}.zip`;
      document.body.appendChild(a); a.click(); a.remove();
      setTimeout(()=>URL.revokeObjectURL(url),0);
      setProgress(100,'Done — ZIP downloaded');
    }catch(err){
      console.error(err);
      setProgress(0,'Processing failed');
    }
  }
  </script>
</body>
</html>


